// Copyright Nu Quantum Ltd
// Copyright 2026 Shareef Jalloq
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv

package usb_uart_csr_reg_pkg;

  // Address width
  parameter int BlockAw = 6;


  // tx_data
  typedef struct packed {
    logic [31:0]q;
  } usb_uart_csr_reg2hw_tx_data_t;

  // ctrl
  typedef struct packed {
    struct packed {
      logic q;
    } tx_clear;
    struct packed {
      logic q;
    } rx_flush;
    struct packed {
      logic q;
    } tx_flush;
    struct packed {
      logic q;
    } thresh_flush_en;
    struct packed {
      logic q;
    } timeout_flush_en;
    struct packed {
      logic q;
    } char_flush_en;
    struct packed {
      logic q;
    } rx_en;
    struct packed {
      logic q;
    } tx_en;
  } usb_uart_csr_reg2hw_ctrl_t;

  // timeout
  typedef struct packed {
    logic [31:0]q;
  } usb_uart_csr_reg2hw_timeout_t;

  // thresh
  typedef struct packed {
    logic [7:0]q;
  } usb_uart_csr_reg2hw_thresh_t;

  // flush_char
  typedef struct packed {
    logic [7:0]q;
  } usb_uart_csr_reg2hw_flush_char_t;

  // irq_status
  typedef struct packed {
    struct packed {
      logic q;
    } len_overflow;
    struct packed {
      logic q;
    } rx_overflow;
    struct packed {
      logic q;
    } tx_empty;
    struct packed {
      logic q;
    } rx_valid;
  } usb_uart_csr_reg2hw_irq_status_t;

  // irq_enable
  typedef struct packed {
    struct packed {
      logic q;
    } len_overflow;
    struct packed {
      logic q;
    } rx_overflow;
    struct packed {
      logic q;
    } tx_empty;
    struct packed {
      logic q;
    } rx_valid;
  } usb_uart_csr_reg2hw_irq_enable_t;

  // tx_data
  typedef struct packed {
    logic [31:0] d;
    logic de;
  } usb_uart_csr_hw2reg_tx_data_t;

  // rx_data
  typedef struct packed {
    logic [31:0] d;
  } usb_uart_csr_hw2reg_rx_data_t;

  // rx_len
  typedef struct packed {
    logic [31:0] d;
  } usb_uart_csr_hw2reg_rx_len_t;

  // status
  typedef struct packed {
    struct packed {
      logic [3:0] d;
    } rx_packets;
    struct packed {
      logic [3:0] d;
    } tx_level;
    struct packed {
      logic  d;
    } rx_full;
    struct packed {
      logic  d;
    } rx_valid;
    struct packed {
      logic  d;
    } tx_full;
    struct packed {
      logic  d;
    } tx_empty;
  } usb_uart_csr_hw2reg_status_t;

  // ctrl
  typedef struct packed {
    struct packed {
      logic  d;
      logic de;
    } tx_clear;
    struct packed {
      logic  d;
      logic de;
    } rx_flush;
    struct packed {
      logic  d;
      logic de;
    } tx_flush;
    struct packed {
      logic  d;
      logic de;
    } thresh_flush_en;
    struct packed {
      logic  d;
      logic de;
    } timeout_flush_en;
    struct packed {
      logic  d;
      logic de;
    } char_flush_en;
    struct packed {
      logic  d;
      logic de;
    } rx_en;
    struct packed {
      logic  d;
      logic de;
    } tx_en;
  } usb_uart_csr_hw2reg_ctrl_t;

  // timeout
  typedef struct packed {
    logic [31:0] d;
    logic de;
  } usb_uart_csr_hw2reg_timeout_t;

  // thresh
  typedef struct packed {
    logic [7:0] d;
    logic de;
  } usb_uart_csr_hw2reg_thresh_t;

  // flush_char
  typedef struct packed {
    logic [7:0] d;
    logic de;
  } usb_uart_csr_hw2reg_flush_char_t;

  // irq_status
  typedef struct packed {
    struct packed {
      logic  d;
      logic de;
    } len_overflow;
    struct packed {
      logic  d;
      logic de;
    } rx_overflow;
    struct packed {
      logic  d;
      logic de;
    } tx_empty;
    struct packed {
      logic  d;
      logic de;
    } rx_valid;
  } usb_uart_csr_hw2reg_irq_status_t;

  // irq_enable
  typedef struct packed {
    struct packed {
      logic  d;
      logic de;
    } len_overflow;
    struct packed {
      logic  d;
      logic de;
    } rx_overflow;
    struct packed {
      logic  d;
      logic de;
    } tx_empty;
    struct packed {
      logic  d;
      logic de;
    } rx_valid;
  } usb_uart_csr_hw2reg_irq_enable_t;


  // Register -> HW
  typedef struct packed {
    usb_uart_csr_reg2hw_tx_data_t tx_data; // 95:64
    usb_uart_csr_reg2hw_ctrl_t ctrl; // 63:56
    usb_uart_csr_reg2hw_timeout_t timeout; // 55:24
    usb_uart_csr_reg2hw_thresh_t thresh; // 23:16
    usb_uart_csr_reg2hw_flush_char_t flush_char; // 15:8
    usb_uart_csr_reg2hw_irq_status_t irq_status; // 7:4
    usb_uart_csr_reg2hw_irq_enable_t irq_enable; // 3:0
  } usb_uart_csr_reg2hw_t;

  // HW -> Register
  typedef struct packed {
    usb_uart_csr_hw2reg_rx_data_t rx_data; // 89:58
    usb_uart_csr_hw2reg_rx_len_t rx_len; // 57:26
    usb_uart_csr_hw2reg_status_t status; // 25:8
    usb_uart_csr_hw2reg_irq_status_t irq_status; // 7:0
  } usb_uart_csr_hw2reg_t;

  // Register address offsets
  parameter logic [BlockAw-1:0] USB_UART_CSR_TX_DATA_OFFSET = 6'h0;
  parameter logic [BlockAw-1:0] USB_UART_CSR_RX_DATA_OFFSET = 6'h4;
  parameter logic [BlockAw-1:0] USB_UART_CSR_RX_LEN_OFFSET = 6'h8;
  parameter logic [BlockAw-1:0] USB_UART_CSR_STATUS_OFFSET = 6'hC;
  parameter logic [BlockAw-1:0] USB_UART_CSR_CTRL_OFFSET = 6'h10;
  parameter logic [BlockAw-1:0] USB_UART_CSR_TIMEOUT_OFFSET = 6'h14;
  parameter logic [BlockAw-1:0] USB_UART_CSR_THRESH_OFFSET = 6'h18;
  parameter logic [BlockAw-1:0] USB_UART_CSR_FLUSH_CHAR_OFFSET = 6'h1C;
  parameter logic [BlockAw-1:0] USB_UART_CSR_IRQ_STATUS_OFFSET = 6'h20;
  parameter logic [BlockAw-1:0] USB_UART_CSR_IRQ_ENABLE_OFFSET = 6'h24;

endpackage

