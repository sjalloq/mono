// Copyright Nu Quantum Ltd
// Copyright 2026 Shareef Jalloq
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv


module usb_uart_csr_reg_top
  import rdl_subreg_pkg::*;
  import usb_uart_csr_reg_pkg::*;
#(
  parameter reset_type_e ResetType = ActiveHighSync,
  localparam int AW                = 6,
  localparam int DW                = 32
) (
  input logic clk,
  input logic rst,

  // CPU I/F
  input logic           reg_we,
  input logic           reg_re,
  input logic [AW-1:0]  reg_addr,
  input logic [DW-1:0]  reg_wdata,
  output logic [DW-1:0] reg_rdata,

  // HW I/F
  output usb_uart_csr_reg_pkg::usb_uart_csr_reg2hw_t reg2hw, // Write
  input  usb_uart_csr_reg_pkg::usb_uart_csr_hw2reg_t hw2reg  // Read
);

  // --------------------------------------------------------------------------------
  // Software Logic Declarations
  // --------------------------------------------------------------------------------

  logic tx_data_we;
  logic [31:0] tx_data_data_wd;
  logic rx_data_re;
  logic rx_len_re;
  logic status_re;
  logic ctrl_re;
  logic ctrl_we;
  logic  ctrl_tx_en_wd;
  logic  ctrl_rx_en_wd;
  logic  ctrl_char_flush_en_wd;
  logic  ctrl_timeout_flush_en_wd;
  logic  ctrl_thresh_flush_en_wd;
  logic  ctrl_tx_flush_wd;
  logic  ctrl_rx_flush_wd;
  logic  ctrl_tx_clear_wd;
  logic timeout_re;
  logic timeout_we;
  logic [31:0] timeout_cycles_wd;
  logic thresh_re;
  logic thresh_we;
  logic [7:0] thresh_thresh_wd;
  logic flush_char_re;
  logic flush_char_we;
  logic [7:0] flush_char_character_wd;
  logic irq_status_re;
  logic irq_status_we;
  logic  irq_status_rx_valid_wd;
  logic  irq_status_tx_empty_wd;
  logic  irq_status_rx_overflow_wd;
  logic  irq_status_len_overflow_wd;
  logic irq_enable_re;
  logic irq_enable_we;
  logic  irq_enable_rx_valid_wd;
  logic  irq_enable_tx_empty_wd;
  logic  irq_enable_rx_overflow_wd;
  logic  irq_enable_len_overflow_wd;

  // --------------------------------------------------------------------------------
  // Field Logic
  // --------------------------------------------------------------------------------

  // Register[tx_data] Field[data] Bits[31:0]
  rdl_subreg_ext #(
    .DW (32)
  ) u_tx_data_data (
    .re  (),
    .we  (tx_data_we),
    .wd  (tx_data_data_wd),
    .d   ('0),
    .qe  (),
    .qre (),
    .q   (reg2hw.tx_data.q),
    .qs  ()
  );

  // Register[rx_data] Field[data] Bits[31:0]
  logic [31:0] rx_data_data_qs;
  assign rx_data_data_qs = hw2reg.rx_data.d;

  // Register[rx_len] Field[len] Bits[31:0]
  logic [31:0] rx_len_len_qs;
  assign rx_len_len_qs = hw2reg.rx_len.d;

  // Register[status] Field[tx_empty] Bits[0]
  logic  status_tx_empty_qs;
  assign status_tx_empty_qs = hw2reg.status.tx_empty.d;

  // Register[status] Field[tx_full] Bits[1]
  logic  status_tx_full_qs;
  assign status_tx_full_qs = hw2reg.status.tx_full.d;

  // Register[status] Field[rx_valid] Bits[2]
  logic  status_rx_valid_qs;
  assign status_rx_valid_qs = hw2reg.status.rx_valid.d;

  // Register[status] Field[rx_full] Bits[3]
  logic  status_rx_full_qs;
  assign status_rx_full_qs = hw2reg.status.rx_full.d;

  // Register[status] Field[tx_level] Bits[7:4]
  logic [3:0] status_tx_level_qs;
  assign status_tx_level_qs = hw2reg.status.tx_level.d;

  // Register[status] Field[rx_packets] Bits[11:8]
  logic [3:0] status_rx_packets_qs;
  assign status_rx_packets_qs = hw2reg.status.rx_packets.d;

  // Register[ctrl] Field[tx_en] Bits[0]
  logic  ctrl_tx_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_tx_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_tx_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_tx_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.tx_en.q)
  );

  // Register[ctrl] Field[rx_en] Bits[1]
  logic  ctrl_rx_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_rx_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_rx_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_rx_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.rx_en.q)
  );

  // Register[ctrl] Field[char_flush_en] Bits[2]
  logic  ctrl_char_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_char_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_char_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_char_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.char_flush_en.q)
  );

  // Register[ctrl] Field[timeout_flush_en] Bits[3]
  logic  ctrl_timeout_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_timeout_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_timeout_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_timeout_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.timeout_flush_en.q)
  );

  // Register[ctrl] Field[thresh_flush_en] Bits[4]
  logic  ctrl_thresh_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_thresh_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_thresh_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_thresh_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.thresh_flush_en.q)
  );

  // Register[ctrl] Field[tx_flush] Bits[5]
  logic  ctrl_tx_flush_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_tx_flush (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_tx_flush_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_tx_flush_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.tx_flush.q)
  );

  // Register[ctrl] Field[rx_flush] Bits[6]
  logic  ctrl_rx_flush_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_rx_flush (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_rx_flush_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_rx_flush_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.rx_flush.q)
  );

  // Register[ctrl] Field[tx_clear] Bits[7]
  logic  ctrl_tx_clear_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_tx_clear (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_tx_clear_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_tx_clear_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.tx_clear.q)
  );

  // Register[timeout] Field[cycles] Bits[31:0]
  logic [31:0] timeout_cycles_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd100000),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_timeout_cycles (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (timeout_we),
    .wd  (timeout_cycles_wd),
    .de  ('0),
    .d   ('0),
    .qs  (timeout_cycles_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.timeout.q)
  );

  // Register[thresh] Field[thresh] Bits[7:0]
  logic [7:0] thresh_thresh_qs;
  rdl_subreg #(
    .DW         (8),
    .ResetType  (ResetType),
    .ResetValue (8'd8),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_thresh_thresh (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (thresh_we),
    .wd  (thresh_thresh_wd),
    .de  ('0),
    .d   ('0),
    .qs  (thresh_thresh_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.thresh.q)
  );

  // Register[flush_char] Field[character] Bits[7:0]
  logic [7:0] flush_char_character_qs;
  rdl_subreg #(
    .DW         (8),
    .ResetType  (ResetType),
    .ResetValue (8'd10),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_flush_char_character (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (flush_char_we),
    .wd  (flush_char_character_wd),
    .de  ('0),
    .d   ('0),
    .qs  (flush_char_character_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.flush_char.q)
  );

  // Register[irq_status] Field[rx_valid] Bits[0]
  logic  irq_status_rx_valid_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_irq_status_rx_valid (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_status_we),
    .wd  (irq_status_rx_valid_wd),
    .de  (hw2reg.irq_status.rx_valid.de),
    .d   (hw2reg.irq_status.rx_valid.d),
    .qs  (irq_status_rx_valid_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_status.rx_valid.q)
  );

  // Register[irq_status] Field[tx_empty] Bits[1]
  logic  irq_status_tx_empty_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_irq_status_tx_empty (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_status_we),
    .wd  (irq_status_tx_empty_wd),
    .de  (hw2reg.irq_status.tx_empty.de),
    .d   (hw2reg.irq_status.tx_empty.d),
    .qs  (irq_status_tx_empty_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_status.tx_empty.q)
  );

  // Register[irq_status] Field[rx_overflow] Bits[2]
  logic  irq_status_rx_overflow_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_irq_status_rx_overflow (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_status_we),
    .wd  (irq_status_rx_overflow_wd),
    .de  (hw2reg.irq_status.rx_overflow.de),
    .d   (hw2reg.irq_status.rx_overflow.d),
    .qs  (irq_status_rx_overflow_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_status.rx_overflow.q)
  );

  // Register[irq_status] Field[len_overflow] Bits[3]
  logic  irq_status_len_overflow_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_irq_status_len_overflow (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_status_we),
    .wd  (irq_status_len_overflow_wd),
    .de  (hw2reg.irq_status.len_overflow.de),
    .d   (hw2reg.irq_status.len_overflow.d),
    .qs  (irq_status_len_overflow_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_status.len_overflow.q)
  );

  // Register[irq_enable] Field[rx_valid] Bits[0]
  logic  irq_enable_rx_valid_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_enable_rx_valid (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_enable_we),
    .wd  (irq_enable_rx_valid_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_enable_rx_valid_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_enable.rx_valid.q)
  );

  // Register[irq_enable] Field[tx_empty] Bits[1]
  logic  irq_enable_tx_empty_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_enable_tx_empty (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_enable_we),
    .wd  (irq_enable_tx_empty_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_enable_tx_empty_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_enable.tx_empty.q)
  );

  // Register[irq_enable] Field[rx_overflow] Bits[2]
  logic  irq_enable_rx_overflow_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_enable_rx_overflow (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_enable_we),
    .wd  (irq_enable_rx_overflow_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_enable_rx_overflow_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_enable.rx_overflow.q)
  );

  // Register[irq_enable] Field[len_overflow] Bits[3]
  logic  irq_enable_len_overflow_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_enable_len_overflow (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_enable_we),
    .wd  (irq_enable_len_overflow_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_enable_len_overflow_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_enable.len_overflow.q)
  );


  // --------------------------------------------------------------------------------
  // Address Decode
  // --------------------------------------------------------------------------------

  logic [9:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[0] = (reg_addr == USB_UART_CSR_TX_DATA_OFFSET);
    addr_hit[1] = (reg_addr == USB_UART_CSR_RX_DATA_OFFSET);
    addr_hit[2] = (reg_addr == USB_UART_CSR_RX_LEN_OFFSET);
    addr_hit[3] = (reg_addr == USB_UART_CSR_STATUS_OFFSET);
    addr_hit[4] = (reg_addr == USB_UART_CSR_CTRL_OFFSET);
    addr_hit[5] = (reg_addr == USB_UART_CSR_TIMEOUT_OFFSET);
    addr_hit[6] = (reg_addr == USB_UART_CSR_THRESH_OFFSET);
    addr_hit[7] = (reg_addr == USB_UART_CSR_FLUSH_CHAR_OFFSET);
    addr_hit[8] = (reg_addr == USB_UART_CSR_IRQ_STATUS_OFFSET);
    addr_hit[9] = (reg_addr == USB_UART_CSR_IRQ_ENABLE_OFFSET);
  end

  // --------------------------------------------------------------------------------
  // Write Enables
  // --------------------------------------------------------------------------------

  assign tx_data_we = addr_hit[0] && reg_we;
  assign tx_data_data_wd = reg_wdata[31:0];
  assign rx_data_re = addr_hit[1] && reg_re;
  assign rx_len_re = addr_hit[2] && reg_re;
  assign status_re = addr_hit[3] && reg_re;
  assign ctrl_we = addr_hit[4] && reg_we;
  assign ctrl_re = addr_hit[4] && reg_re;
  assign ctrl_tx_en_wd = reg_wdata[0];
  assign ctrl_rx_en_wd = reg_wdata[1];
  assign ctrl_char_flush_en_wd = reg_wdata[2];
  assign ctrl_timeout_flush_en_wd = reg_wdata[3];
  assign ctrl_thresh_flush_en_wd = reg_wdata[4];
  assign ctrl_tx_flush_wd = reg_wdata[5];
  assign ctrl_rx_flush_wd = reg_wdata[6];
  assign ctrl_tx_clear_wd = reg_wdata[7];
  assign timeout_we = addr_hit[5] && reg_we;
  assign timeout_re = addr_hit[5] && reg_re;
  assign timeout_cycles_wd = reg_wdata[31:0];
  assign thresh_we = addr_hit[6] && reg_we;
  assign thresh_re = addr_hit[6] && reg_re;
  assign thresh_thresh_wd = reg_wdata[7:0];
  assign flush_char_we = addr_hit[7] && reg_we;
  assign flush_char_re = addr_hit[7] && reg_re;
  assign flush_char_character_wd = reg_wdata[7:0];
  assign irq_status_we = addr_hit[8] && reg_we;
  assign irq_status_re = addr_hit[8] && reg_re;
  assign irq_status_rx_valid_wd = reg_wdata[0];
  assign irq_status_tx_empty_wd = reg_wdata[1];
  assign irq_status_rx_overflow_wd = reg_wdata[2];
  assign irq_status_len_overflow_wd = reg_wdata[3];
  assign irq_enable_we = addr_hit[9] && reg_we;
  assign irq_enable_re = addr_hit[9] && reg_re;
  assign irq_enable_rx_valid_wd = reg_wdata[0];
  assign irq_enable_tx_empty_wd = reg_wdata[1];
  assign irq_enable_rx_overflow_wd = reg_wdata[2];
  assign irq_enable_len_overflow_wd = reg_wdata[3];

  // --------------------------------------------------------------------------------
  // Read Data Mux
  // --------------------------------------------------------------------------------

  always_comb begin
    reg_rdata = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata[31:0] = '0;
      end
      addr_hit[1]: begin
        reg_rdata[31:0] = rx_data_data_qs;
      end
      addr_hit[2]: begin
        reg_rdata[31:0] = rx_len_len_qs;
      end
      addr_hit[3]: begin
        reg_rdata[0] = status_tx_empty_qs;
        reg_rdata[1] = status_tx_full_qs;
        reg_rdata[2] = status_rx_valid_qs;
        reg_rdata[3] = status_rx_full_qs;
        reg_rdata[7:4] = status_tx_level_qs;
        reg_rdata[11:8] = status_rx_packets_qs;
      end
      addr_hit[4]: begin
        reg_rdata[0] = ctrl_tx_en_qs;
        reg_rdata[1] = ctrl_rx_en_qs;
        reg_rdata[2] = ctrl_char_flush_en_qs;
        reg_rdata[3] = ctrl_timeout_flush_en_qs;
        reg_rdata[4] = ctrl_thresh_flush_en_qs;
        reg_rdata[5] = ctrl_tx_flush_qs;
        reg_rdata[6] = ctrl_rx_flush_qs;
        reg_rdata[7] = ctrl_tx_clear_qs;
      end
      addr_hit[5]: begin
        reg_rdata[31:0] = timeout_cycles_qs;
      end
      addr_hit[6]: begin
        reg_rdata[7:0] = thresh_thresh_qs;
      end
      addr_hit[7]: begin
        reg_rdata[7:0] = flush_char_character_qs;
      end
      addr_hit[8]: begin
        reg_rdata[0] = irq_status_rx_valid_qs;
        reg_rdata[1] = irq_status_tx_empty_qs;
        reg_rdata[2] = irq_status_rx_overflow_qs;
        reg_rdata[3] = irq_status_len_overflow_qs;
      end
      addr_hit[9]: begin
        reg_rdata[0] = irq_enable_rx_valid_qs;
        reg_rdata[1] = irq_enable_tx_empty_qs;
        reg_rdata[2] = irq_enable_rx_overflow_qs;
        reg_rdata[3] = irq_enable_len_overflow_qs;
      end
      default: begin
        reg_rdata = 'X;
      end
    endcase
  end

endmodule
