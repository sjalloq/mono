// Copyright Nu Quantum Ltd
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv


module usb_uart_csr_reg_top
  import rdl_subreg_pkg::*;
  import usb_uart_csr_reg_pkg::*;
#(
  parameter reset_type_e ResetType = ActiveHighSync,
  localparam int AW                = 5,
  localparam int DW                = 32
) (
  input logic clk,
  input logic rst,

  // CPU I/F
  input logic           reg_we,
  input logic           reg_re,
  input logic [AW-1:0]  reg_addr,
  input logic [DW-1:0]  reg_wdata,
  output logic [DW-1:0] reg_rdata,

  // HW I/F
  output usb_uart_csr_reg_pkg::usb_uart_csr_reg2hw_t reg2hw, // Write
  input  usb_uart_csr_reg_pkg::usb_uart_csr_hw2reg_t hw2reg  // Read
);

  // --------------------------------------------------------------------------------
  // Software Logic Declarations
  // --------------------------------------------------------------------------------

  logic tx_data_we;
  logic [31:0] tx_data_data_wd;
  logic rx_data_re;
  logic rx_len_re;
  logic status_re;
  logic ctrl_re;
  logic ctrl_we;
  logic  ctrl_tx_en_wd;
  logic  ctrl_rx_en_wd;
  logic  ctrl_nl_flush_en_wd;
  logic  ctrl_timeout_flush_en_wd;
  logic  ctrl_thresh_flush_en_wd;
  logic  ctrl_tx_flush_wd;
  logic  ctrl_rx_flush_wd;
  logic  ctrl_irq_rx_en_wd;
  logic  ctrl_irq_tx_empty_en_wd;
  logic timeout_re;
  logic timeout_we;
  logic [31:0] timeout_cycles_wd;
  logic thresh_re;
  logic thresh_we;
  logic [7:0] thresh_thresh_wd;

  // --------------------------------------------------------------------------------
  // Field Logic
  // --------------------------------------------------------------------------------

  // Register[tx_data] Field[data] Bits[31:0]
  rdl_subreg_ext #(
    .DW (32)
  ) u_tx_data_data (
    .re  (),
    .we  (tx_data_we),
    .wd  (tx_data_data_wd),
    .d   ('0),
    .qe  (),
    .qre (),
    .q   (reg2hw.tx_data.q),
    .qs  ()
  );

  // Register[rx_data] Field[data] Bits[31:0]
  logic [31:0] rx_data_data_qs;
  assign rx_data_data_qs = hw2reg.rx_data.d;

  // Register[rx_len] Field[len] Bits[31:0]
  logic [31:0] rx_len_len_qs;
  assign rx_len_len_qs = hw2reg.rx_len.d;

  // Register[status] Field[tx_empty] Bits[0]
  logic  status_tx_empty_qs;
  assign status_tx_empty_qs = hw2reg.status.tx_empty.d;

  // Register[status] Field[tx_full] Bits[1]
  logic  status_tx_full_qs;
  assign status_tx_full_qs = hw2reg.status.tx_full.d;

  // Register[status] Field[rx_valid] Bits[2]
  logic  status_rx_valid_qs;
  assign status_rx_valid_qs = hw2reg.status.rx_valid.d;

  // Register[status] Field[rx_full] Bits[3]
  logic  status_rx_full_qs;
  assign status_rx_full_qs = hw2reg.status.rx_full.d;

  // Register[status] Field[tx_level] Bits[7:4]
  logic [3:0] status_tx_level_qs;
  assign status_tx_level_qs = hw2reg.status.tx_level.d;

  // Register[status] Field[rx_packets] Bits[11:8]
  logic [3:0] status_rx_packets_qs;
  assign status_rx_packets_qs = hw2reg.status.rx_packets.d;

  // Register[ctrl] Field[tx_en] Bits[0]
  logic  ctrl_tx_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_tx_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_tx_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_tx_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.tx_en.q)
  );

  // Register[ctrl] Field[rx_en] Bits[1]
  logic  ctrl_rx_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_rx_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_rx_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_rx_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.rx_en.q)
  );

  // Register[ctrl] Field[nl_flush_en] Bits[2]
  logic  ctrl_nl_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_nl_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_nl_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_nl_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.nl_flush_en.q)
  );

  // Register[ctrl] Field[timeout_flush_en] Bits[3]
  logic  ctrl_timeout_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd1),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_timeout_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_timeout_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_timeout_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.timeout_flush_en.q)
  );

  // Register[ctrl] Field[thresh_flush_en] Bits[4]
  logic  ctrl_thresh_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_thresh_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_thresh_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_thresh_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.thresh_flush_en.q)
  );

  // Register[ctrl] Field[tx_flush] Bits[5]
  logic  ctrl_tx_flush_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_tx_flush (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_tx_flush_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_tx_flush_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.tx_flush.q)
  );

  // Register[ctrl] Field[rx_flush] Bits[6]
  logic  ctrl_rx_flush_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_rx_flush (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_rx_flush_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_rx_flush_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.rx_flush.q)
  );

  // Register[ctrl] Field[irq_rx_en] Bits[8]
  logic  ctrl_irq_rx_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_irq_rx_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_irq_rx_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_irq_rx_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.irq_rx_en.q)
  );

  // Register[ctrl] Field[irq_tx_empty_en] Bits[9]
  logic  ctrl_irq_tx_empty_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_ctrl_irq_tx_empty_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (ctrl_we),
    .wd  (ctrl_irq_tx_empty_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (ctrl_irq_tx_empty_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.ctrl.irq_tx_empty_en.q)
  );

  // Register[timeout] Field[cycles] Bits[31:0]
  logic [31:0] timeout_cycles_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd100000),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_timeout_cycles (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (timeout_we),
    .wd  (timeout_cycles_wd),
    .de  ('0),
    .d   ('0),
    .qs  (timeout_cycles_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.timeout.q)
  );

  // Register[thresh] Field[thresh] Bits[7:0]
  logic [7:0] thresh_thresh_qs;
  rdl_subreg #(
    .DW         (8),
    .ResetType  (ResetType),
    .ResetValue (8'd8),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_thresh_thresh (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (thresh_we),
    .wd  (thresh_thresh_wd),
    .de  ('0),
    .d   ('0),
    .qs  (thresh_thresh_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.thresh.q)
  );


  // --------------------------------------------------------------------------------
  // Address Decode
  // --------------------------------------------------------------------------------

  logic [6:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[0] = (reg_addr == USB_UART_CSR_TX_DATA_OFFSET);
    addr_hit[1] = (reg_addr == USB_UART_CSR_RX_DATA_OFFSET);
    addr_hit[2] = (reg_addr == USB_UART_CSR_RX_LEN_OFFSET);
    addr_hit[3] = (reg_addr == USB_UART_CSR_STATUS_OFFSET);
    addr_hit[4] = (reg_addr == USB_UART_CSR_CTRL_OFFSET);
    addr_hit[5] = (reg_addr == USB_UART_CSR_TIMEOUT_OFFSET);
    addr_hit[6] = (reg_addr == USB_UART_CSR_THRESH_OFFSET);
  end

  // --------------------------------------------------------------------------------
  // Write Enables
  // --------------------------------------------------------------------------------

  assign tx_data_we = addr_hit[0] && reg_we;
  assign tx_data_data_wd = reg_wdata[31:0];
  assign rx_data_re = addr_hit[1] && reg_re;
  assign rx_len_re = addr_hit[2] && reg_re;
  assign status_re = addr_hit[3] && reg_re;
  assign ctrl_we = addr_hit[4] && reg_we;
  assign ctrl_re = addr_hit[4] && reg_re;
  assign ctrl_tx_en_wd = reg_wdata[0];
  assign ctrl_rx_en_wd = reg_wdata[1];
  assign ctrl_nl_flush_en_wd = reg_wdata[2];
  assign ctrl_timeout_flush_en_wd = reg_wdata[3];
  assign ctrl_thresh_flush_en_wd = reg_wdata[4];
  assign ctrl_tx_flush_wd = reg_wdata[5];
  assign ctrl_rx_flush_wd = reg_wdata[6];
  assign ctrl_irq_rx_en_wd = reg_wdata[8];
  assign ctrl_irq_tx_empty_en_wd = reg_wdata[9];
  assign timeout_we = addr_hit[5] && reg_we;
  assign timeout_re = addr_hit[5] && reg_re;
  assign timeout_cycles_wd = reg_wdata[31:0];
  assign thresh_we = addr_hit[6] && reg_we;
  assign thresh_re = addr_hit[6] && reg_re;
  assign thresh_thresh_wd = reg_wdata[7:0];

  // --------------------------------------------------------------------------------
  // Read Data Mux
  // --------------------------------------------------------------------------------

  always_comb begin
    reg_rdata = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata[31:0] = '0;
      end
      addr_hit[1]: begin
        reg_rdata[31:0] = rx_data_data_qs;
      end
      addr_hit[2]: begin
        reg_rdata[31:0] = rx_len_len_qs;
      end
      addr_hit[3]: begin
        reg_rdata[0] = status_tx_empty_qs;
        reg_rdata[1] = status_tx_full_qs;
        reg_rdata[2] = status_rx_valid_qs;
        reg_rdata[3] = status_rx_full_qs;
        reg_rdata[7:4] = status_tx_level_qs;
        reg_rdata[11:8] = status_rx_packets_qs;
      end
      addr_hit[4]: begin
        reg_rdata[0] = ctrl_tx_en_qs;
        reg_rdata[1] = ctrl_rx_en_qs;
        reg_rdata[2] = ctrl_nl_flush_en_qs;
        reg_rdata[3] = ctrl_timeout_flush_en_qs;
        reg_rdata[4] = ctrl_thresh_flush_en_qs;
        reg_rdata[5] = ctrl_tx_flush_qs;
        reg_rdata[6] = ctrl_rx_flush_qs;
        reg_rdata[8] = ctrl_irq_rx_en_qs;
        reg_rdata[9] = ctrl_irq_tx_empty_en_qs;
      end
      addr_hit[5]: begin
        reg_rdata[31:0] = timeout_cycles_qs;
      end
      addr_hit[6]: begin
        reg_rdata[7:0] = thresh_thresh_qs;
      end
      default: begin
        reg_rdata = 'X;
      end
    endcase
  end

endmodule
