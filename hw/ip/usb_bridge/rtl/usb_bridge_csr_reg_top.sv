// Copyright Nu Quantum Ltd
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv


module usb_bridge_csr_reg_top
  import rdl_subreg_pkg::*;
  import usb_bridge_csr_reg_pkg::*;
#(
  parameter reset_type_e ResetType = ActiveHighSync,
  localparam int AW                = 6,
  localparam int DW                = 32
) (
  input logic clk,
  input logic rst,

  // CPU I/F
  input logic           reg_we,
  input logic           reg_re,
  input logic [AW-1:0]  reg_addr,
  input logic [DW-1:0]  reg_wdata,
  output logic [DW-1:0] reg_rdata,

  // HW I/F
  output usb_bridge_csr_reg_pkg::usb_bridge_csr_reg2hw_t reg2hw, // Write
  input  usb_bridge_csr_reg_pkg::usb_bridge_csr_hw2reg_t hw2reg  // Read
);

  // --------------------------------------------------------------------------------
  // Software Logic Declarations
  // --------------------------------------------------------------------------------

  logic tx_data_we;
  logic [31:0] tx_data_data_wd;
  logic rx_data_re;
  logic status_re;
  logic status_we;
  logic  status_tx_ready_wd;
  logic  status_tx_full_wd;
  logic  status_tx_empty_wd;
  logic  status_rx_valid_wd;
  logic  status_rx_full_wd;
  logic  status_rx_empty_wd;
  logic  status_tx_overflow_wd;
  logic  status_rx_overflow_wd;
  logic control_re;
  logic control_we;
  logic  control_tx_enable_wd;
  logic  control_rx_enable_wd;
  logic  control_tx_flush_wd;
  logic  control_rx_flush_wd;
  logic  control_timeout_flush_en_wd;
  logic  control_thresh_flush_en_wd;
  logic  control_char_flush_en_wd;
  logic  control_loopback_wd;
  logic  control_irq_tx_empty_en_wd;
  logic  control_irq_rx_valid_en_wd;
  logic  control_irq_tx_low_en_wd;
  logic  control_irq_rx_high_en_wd;
  logic tx_level_re;
  logic rx_level_re;
  logic flush_timeout_re;
  logic flush_timeout_we;
  logic [31:0] flush_timeout_timeout_wd;
  logic flush_thresh_re;
  logic flush_thresh_we;
  logic [15:0] flush_thresh_threshold_wd;
  logic flush_char_re;
  logic flush_char_we;
  logic [7:0] flush_char_character_wd;
  logic tx_watermark_re;
  logic tx_watermark_we;
  logic [15:0] tx_watermark_threshold_wd;
  logic rx_watermark_re;
  logic rx_watermark_we;
  logic [15:0] rx_watermark_threshold_wd;

  // --------------------------------------------------------------------------------
  // Field Logic
  // --------------------------------------------------------------------------------

  // Register[tx_data] Field[data] Bits[31:0]
  rdl_subreg_ext #(
    .DW (32)
  ) u_tx_data_data (
    .re  (),
    .we  (tx_data_we),
    .wd  (tx_data_data_wd),
    .d   ('0),
    .qe  (),
    .qre (),
    .q   (reg2hw.tx_data.q),
    .qs  ()
  );

  // Register[rx_data] Field[data] Bits[31:0]
  logic [31:0] rx_data_data_qs;
  assign rx_data_data_qs = hw2reg.rx_data.d;

  // Register[status] Field[tx_ready] Bits[0]
  logic  status_tx_ready_qs;
  assign status_tx_ready_qs = hw2reg.status.tx_ready.d;

  // Register[status] Field[tx_full] Bits[1]
  logic  status_tx_full_qs;
  assign status_tx_full_qs = hw2reg.status.tx_full.d;

  // Register[status] Field[tx_empty] Bits[2]
  logic  status_tx_empty_qs;
  assign status_tx_empty_qs = hw2reg.status.tx_empty.d;

  // Register[status] Field[rx_valid] Bits[3]
  logic  status_rx_valid_qs;
  assign status_rx_valid_qs = hw2reg.status.rx_valid.d;

  // Register[status] Field[rx_full] Bits[4]
  logic  status_rx_full_qs;
  assign status_rx_full_qs = hw2reg.status.rx_full.d;

  // Register[status] Field[rx_empty] Bits[5]
  logic  status_rx_empty_qs;
  assign status_rx_empty_qs = hw2reg.status.rx_empty.d;

  // Register[status] Field[tx_overflow] Bits[6]
  logic  status_tx_overflow_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_status_tx_overflow (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (status_we),
    .wd  (status_tx_overflow_wd),
    .de  (hw2reg.status.tx_overflow.de),
    .d   (hw2reg.status.tx_overflow.d),
    .qs  (status_tx_overflow_qs),
    .qe  (),
    .qre (),
    .q   ()
  );

  // Register[status] Field[rx_overflow] Bits[7]
  logic  status_rx_overflow_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_status_rx_overflow (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (status_we),
    .wd  (status_rx_overflow_wd),
    .de  (hw2reg.status.rx_overflow.de),
    .d   (hw2reg.status.rx_overflow.d),
    .qs  (status_rx_overflow_qs),
    .qe  (),
    .qre (),
    .q   ()
  );

  // Register[control] Field[tx_enable] Bits[0]
  logic  control_tx_enable_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_tx_enable (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_tx_enable_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_tx_enable_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.tx_enable.q)
  );

  // Register[control] Field[rx_enable] Bits[1]
  logic  control_rx_enable_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_rx_enable (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_rx_enable_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_rx_enable_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.rx_enable.q)
  );

  // Register[control] Field[tx_flush] Bits[2]
  logic  control_tx_flush_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_tx_flush (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_tx_flush_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_tx_flush_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.tx_flush.q)
  );

  // Register[control] Field[rx_flush] Bits[3]
  logic  control_rx_flush_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_rx_flush (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_rx_flush_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_rx_flush_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.rx_flush.q)
  );

  // Register[control] Field[timeout_flush_en] Bits[4]
  logic  control_timeout_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_timeout_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_timeout_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_timeout_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.timeout_flush_en.q)
  );

  // Register[control] Field[thresh_flush_en] Bits[5]
  logic  control_thresh_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_thresh_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_thresh_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_thresh_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.thresh_flush_en.q)
  );

  // Register[control] Field[char_flush_en] Bits[6]
  logic  control_char_flush_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_char_flush_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_char_flush_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_char_flush_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.char_flush_en.q)
  );

  // Register[control] Field[loopback] Bits[7]
  logic  control_loopback_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_loopback (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_loopback_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_loopback_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.loopback.q)
  );

  // Register[control] Field[irq_tx_empty_en] Bits[8]
  logic  control_irq_tx_empty_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_irq_tx_empty_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_irq_tx_empty_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_irq_tx_empty_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.irq_tx_empty_en.q)
  );

  // Register[control] Field[irq_rx_valid_en] Bits[9]
  logic  control_irq_rx_valid_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_irq_rx_valid_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_irq_rx_valid_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_irq_rx_valid_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.irq_rx_valid_en.q)
  );

  // Register[control] Field[irq_tx_low_en] Bits[10]
  logic  control_irq_tx_low_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_irq_tx_low_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_irq_tx_low_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_irq_tx_low_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.irq_tx_low_en.q)
  );

  // Register[control] Field[irq_rx_high_en] Bits[11]
  logic  control_irq_rx_high_en_qs;
  rdl_subreg #(
    .DW         (1),
    .ResetType  (ResetType),
    .ResetValue (1'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_control_irq_rx_high_en (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (control_we),
    .wd  (control_irq_rx_high_en_wd),
    .de  ('0),
    .d   ('0),
    .qs  (control_irq_rx_high_en_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.control.irq_rx_high_en.q)
  );

  // Register[tx_level] Field[cnt] Bits[15:0]
  logic [15:0] tx_level_cnt_qs;
  assign tx_level_cnt_qs = hw2reg.tx_level.d;

  // Register[rx_level] Field[cnt] Bits[15:0]
  logic [15:0] rx_level_cnt_qs;
  assign rx_level_cnt_qs = hw2reg.rx_level.d;

  // Register[flush_timeout] Field[timeout] Bits[31:0]
  logic [31:0] flush_timeout_timeout_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd10000),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_flush_timeout_timeout (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (flush_timeout_we),
    .wd  (flush_timeout_timeout_wd),
    .de  ('0),
    .d   ('0),
    .qs  (flush_timeout_timeout_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.flush_timeout.q)
  );

  // Register[flush_thresh] Field[threshold] Bits[15:0]
  logic [15:0] flush_thresh_threshold_qs;
  rdl_subreg #(
    .DW         (16),
    .ResetType  (ResetType),
    .ResetValue (16'd32),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_flush_thresh_threshold (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (flush_thresh_we),
    .wd  (flush_thresh_threshold_wd),
    .de  ('0),
    .d   ('0),
    .qs  (flush_thresh_threshold_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.flush_thresh.q)
  );

  // Register[flush_char] Field[character] Bits[7:0]
  logic [7:0] flush_char_character_qs;
  rdl_subreg #(
    .DW         (8),
    .ResetType  (ResetType),
    .ResetValue (8'd10),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_flush_char_character (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (flush_char_we),
    .wd  (flush_char_character_wd),
    .de  ('0),
    .d   ('0),
    .qs  (flush_char_character_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.flush_char.q)
  );

  // Register[tx_watermark] Field[threshold] Bits[15:0]
  logic [15:0] tx_watermark_threshold_qs;
  rdl_subreg #(
    .DW         (16),
    .ResetType  (ResetType),
    .ResetValue (16'd8),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_tx_watermark_threshold (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (tx_watermark_we),
    .wd  (tx_watermark_threshold_wd),
    .de  ('0),
    .d   ('0),
    .qs  (tx_watermark_threshold_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.tx_watermark.q)
  );

  // Register[rx_watermark] Field[threshold] Bits[15:0]
  logic [15:0] rx_watermark_threshold_qs;
  rdl_subreg #(
    .DW         (16),
    .ResetType  (ResetType),
    .ResetValue (16'd8),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_rx_watermark_threshold (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (rx_watermark_we),
    .wd  (rx_watermark_threshold_wd),
    .de  ('0),
    .d   ('0),
    .qs  (rx_watermark_threshold_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.rx_watermark.q)
  );


  // --------------------------------------------------------------------------------
  // Address Decode
  // --------------------------------------------------------------------------------

  logic [10:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[ 0] = (reg_addr == USB_BRIDGE_CSR_TX_DATA_OFFSET);
    addr_hit[ 1] = (reg_addr == USB_BRIDGE_CSR_RX_DATA_OFFSET);
    addr_hit[ 2] = (reg_addr == USB_BRIDGE_CSR_STATUS_OFFSET);
    addr_hit[ 3] = (reg_addr == USB_BRIDGE_CSR_CONTROL_OFFSET);
    addr_hit[ 4] = (reg_addr == USB_BRIDGE_CSR_TX_LEVEL_OFFSET);
    addr_hit[ 5] = (reg_addr == USB_BRIDGE_CSR_RX_LEVEL_OFFSET);
    addr_hit[ 6] = (reg_addr == USB_BRIDGE_CSR_FLUSH_TIMEOUT_OFFSET);
    addr_hit[ 7] = (reg_addr == USB_BRIDGE_CSR_FLUSH_THRESH_OFFSET);
    addr_hit[ 8] = (reg_addr == USB_BRIDGE_CSR_FLUSH_CHAR_OFFSET);
    addr_hit[ 9] = (reg_addr == USB_BRIDGE_CSR_TX_WATERMARK_OFFSET);
    addr_hit[10] = (reg_addr == USB_BRIDGE_CSR_RX_WATERMARK_OFFSET);
  end

  // --------------------------------------------------------------------------------
  // Write Enables
  // --------------------------------------------------------------------------------

  assign tx_data_we = addr_hit[0] && reg_we;
  assign tx_data_data_wd = reg_wdata[31:0];
  assign rx_data_re = addr_hit[1] && reg_re;
  assign status_we = addr_hit[2] && reg_we;
  assign status_re = addr_hit[2] && reg_re;
  assign status_tx_overflow_wd = reg_wdata[6];
  assign status_rx_overflow_wd = reg_wdata[7];
  assign control_we = addr_hit[3] && reg_we;
  assign control_re = addr_hit[3] && reg_re;
  assign control_tx_enable_wd = reg_wdata[0];
  assign control_rx_enable_wd = reg_wdata[1];
  assign control_tx_flush_wd = reg_wdata[2];
  assign control_rx_flush_wd = reg_wdata[3];
  assign control_timeout_flush_en_wd = reg_wdata[4];
  assign control_thresh_flush_en_wd = reg_wdata[5];
  assign control_char_flush_en_wd = reg_wdata[6];
  assign control_loopback_wd = reg_wdata[7];
  assign control_irq_tx_empty_en_wd = reg_wdata[8];
  assign control_irq_rx_valid_en_wd = reg_wdata[9];
  assign control_irq_tx_low_en_wd = reg_wdata[10];
  assign control_irq_rx_high_en_wd = reg_wdata[11];
  assign tx_level_re = addr_hit[4] && reg_re;
  assign rx_level_re = addr_hit[5] && reg_re;
  assign flush_timeout_we = addr_hit[6] && reg_we;
  assign flush_timeout_re = addr_hit[6] && reg_re;
  assign flush_timeout_timeout_wd = reg_wdata[31:0];
  assign flush_thresh_we = addr_hit[7] && reg_we;
  assign flush_thresh_re = addr_hit[7] && reg_re;
  assign flush_thresh_threshold_wd = reg_wdata[15:0];
  assign flush_char_we = addr_hit[8] && reg_we;
  assign flush_char_re = addr_hit[8] && reg_re;
  assign flush_char_character_wd = reg_wdata[7:0];
  assign tx_watermark_we = addr_hit[9] && reg_we;
  assign tx_watermark_re = addr_hit[9] && reg_re;
  assign tx_watermark_threshold_wd = reg_wdata[15:0];
  assign rx_watermark_we = addr_hit[10] && reg_we;
  assign rx_watermark_re = addr_hit[10] && reg_re;
  assign rx_watermark_threshold_wd = reg_wdata[15:0];

  // --------------------------------------------------------------------------------
  // Read Data Mux
  // --------------------------------------------------------------------------------

  always_comb begin
    reg_rdata = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata[31:0] = '0;
      end
      addr_hit[1]: begin
        reg_rdata[31:0] = rx_data_data_qs;
      end
      addr_hit[2]: begin
        reg_rdata[0] = status_tx_ready_qs;
        reg_rdata[1] = status_tx_full_qs;
        reg_rdata[2] = status_tx_empty_qs;
        reg_rdata[3] = status_rx_valid_qs;
        reg_rdata[4] = status_rx_full_qs;
        reg_rdata[5] = status_rx_empty_qs;
        reg_rdata[6] = status_tx_overflow_qs;
        reg_rdata[7] = status_rx_overflow_qs;
      end
      addr_hit[3]: begin
        reg_rdata[0] = control_tx_enable_qs;
        reg_rdata[1] = control_rx_enable_qs;
        reg_rdata[2] = control_tx_flush_qs;
        reg_rdata[3] = control_rx_flush_qs;
        reg_rdata[4] = control_timeout_flush_en_qs;
        reg_rdata[5] = control_thresh_flush_en_qs;
        reg_rdata[6] = control_char_flush_en_qs;
        reg_rdata[7] = control_loopback_qs;
        reg_rdata[8] = control_irq_tx_empty_en_qs;
        reg_rdata[9] = control_irq_rx_valid_en_qs;
        reg_rdata[10] = control_irq_tx_low_en_qs;
        reg_rdata[11] = control_irq_rx_high_en_qs;
      end
      addr_hit[4]: begin
        reg_rdata[15:0] = tx_level_cnt_qs;
      end
      addr_hit[5]: begin
        reg_rdata[15:0] = rx_level_cnt_qs;
      end
      addr_hit[6]: begin
        reg_rdata[31:0] = flush_timeout_timeout_qs;
      end
      addr_hit[7]: begin
        reg_rdata[15:0] = flush_thresh_threshold_qs;
      end
      addr_hit[8]: begin
        reg_rdata[7:0] = flush_char_character_qs;
      end
      addr_hit[9]: begin
        reg_rdata[15:0] = tx_watermark_threshold_qs;
      end
      addr_hit[10]: begin
        reg_rdata[15:0] = rx_watermark_threshold_qs;
      end
      default: begin
        reg_rdata = 'X;
      end
    endcase
  end

endmodule
