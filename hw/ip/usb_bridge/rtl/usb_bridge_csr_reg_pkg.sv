// Copyright Nu Quantum Ltd
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv

package usb_bridge_csr_reg_pkg;

  // Address width
  parameter int BlockAw = 6;


  // tx_data
  typedef struct packed {
    logic [31:0]q;
  } usb_bridge_csr_reg2hw_tx_data_t;

  // control
  typedef struct packed {
    struct packed {
      logic q;
    } irq_rx_high_en;
    struct packed {
      logic q;
    } irq_tx_low_en;
    struct packed {
      logic q;
    } irq_rx_valid_en;
    struct packed {
      logic q;
    } irq_tx_empty_en;
    struct packed {
      logic q;
    } loopback;
    struct packed {
      logic q;
    } char_flush_en;
    struct packed {
      logic q;
    } thresh_flush_en;
    struct packed {
      logic q;
    } timeout_flush_en;
    struct packed {
      logic q;
    } rx_flush;
    struct packed {
      logic q;
    } tx_flush;
    struct packed {
      logic q;
    } rx_enable;
    struct packed {
      logic q;
    } tx_enable;
  } usb_bridge_csr_reg2hw_control_t;

  // flush_timeout
  typedef struct packed {
    logic [31:0]q;
  } usb_bridge_csr_reg2hw_flush_timeout_t;

  // flush_thresh
  typedef struct packed {
    logic [15:0]q;
  } usb_bridge_csr_reg2hw_flush_thresh_t;

  // flush_char
  typedef struct packed {
    logic [7:0]q;
  } usb_bridge_csr_reg2hw_flush_char_t;

  // tx_watermark
  typedef struct packed {
    logic [15:0]q;
  } usb_bridge_csr_reg2hw_tx_watermark_t;

  // rx_watermark
  typedef struct packed {
    logic [15:0]q;
  } usb_bridge_csr_reg2hw_rx_watermark_t;

  // tx_data
  typedef struct packed {
    logic [31:0] d;
    logic de;
  } usb_bridge_csr_hw2reg_tx_data_t;

  // rx_data
  typedef struct packed {
    logic [31:0] d;
  } usb_bridge_csr_hw2reg_rx_data_t;

  // status
  typedef struct packed {
    struct packed {
      logic  d;
      logic de;
    } rx_overflow;
    struct packed {
      logic  d;
      logic de;
    } tx_overflow;
    struct packed {
      logic  d;
    } rx_empty;
    struct packed {
      logic  d;
    } rx_full;
    struct packed {
      logic  d;
    } rx_valid;
    struct packed {
      logic  d;
    } tx_empty;
    struct packed {
      logic  d;
    } tx_full;
    struct packed {
      logic  d;
    } tx_ready;
  } usb_bridge_csr_hw2reg_status_t;

  // control
  typedef struct packed {
    struct packed {
      logic  d;
      logic de;
    } irq_rx_high_en;
    struct packed {
      logic  d;
      logic de;
    } irq_tx_low_en;
    struct packed {
      logic  d;
      logic de;
    } irq_rx_valid_en;
    struct packed {
      logic  d;
      logic de;
    } irq_tx_empty_en;
    struct packed {
      logic  d;
      logic de;
    } loopback;
    struct packed {
      logic  d;
      logic de;
    } char_flush_en;
    struct packed {
      logic  d;
      logic de;
    } thresh_flush_en;
    struct packed {
      logic  d;
      logic de;
    } timeout_flush_en;
    struct packed {
      logic  d;
      logic de;
    } rx_flush;
    struct packed {
      logic  d;
      logic de;
    } tx_flush;
    struct packed {
      logic  d;
      logic de;
    } rx_enable;
    struct packed {
      logic  d;
      logic de;
    } tx_enable;
  } usb_bridge_csr_hw2reg_control_t;

  // tx_level
  typedef struct packed {
    logic [15:0] d;
  } usb_bridge_csr_hw2reg_tx_level_t;

  // rx_level
  typedef struct packed {
    logic [15:0] d;
  } usb_bridge_csr_hw2reg_rx_level_t;

  // flush_timeout
  typedef struct packed {
    logic [31:0] d;
    logic de;
  } usb_bridge_csr_hw2reg_flush_timeout_t;

  // flush_thresh
  typedef struct packed {
    logic [15:0] d;
    logic de;
  } usb_bridge_csr_hw2reg_flush_thresh_t;

  // flush_char
  typedef struct packed {
    logic [7:0] d;
    logic de;
  } usb_bridge_csr_hw2reg_flush_char_t;

  // tx_watermark
  typedef struct packed {
    logic [15:0] d;
    logic de;
  } usb_bridge_csr_hw2reg_tx_watermark_t;

  // rx_watermark
  typedef struct packed {
    logic [15:0] d;
    logic de;
  } usb_bridge_csr_hw2reg_rx_watermark_t;


  // Register -> HW
  typedef struct packed {
    usb_bridge_csr_reg2hw_tx_data_t tx_data; // 133:102
    usb_bridge_csr_reg2hw_control_t control; // 101:90
    usb_bridge_csr_reg2hw_flush_timeout_t flush_timeout; // 89:58
    usb_bridge_csr_reg2hw_flush_thresh_t flush_thresh; // 57:42
    usb_bridge_csr_reg2hw_flush_char_t flush_char; // 41:34
    usb_bridge_csr_reg2hw_tx_watermark_t tx_watermark; // 33:18
    usb_bridge_csr_reg2hw_rx_watermark_t rx_watermark; // 17:2
  } usb_bridge_csr_reg2hw_t;

  // HW -> Register
  typedef struct packed {
    usb_bridge_csr_hw2reg_rx_data_t rx_data; // 79:48
    usb_bridge_csr_hw2reg_status_t status; // 47:32
    usb_bridge_csr_hw2reg_tx_level_t tx_level; // 31:16
    usb_bridge_csr_hw2reg_rx_level_t rx_level; // 15:0
  } usb_bridge_csr_hw2reg_t;

  // Register address offsets
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_TX_DATA_OFFSET = 6'h0;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_RX_DATA_OFFSET = 6'h4;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_STATUS_OFFSET = 6'h8;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_CONTROL_OFFSET = 6'hC;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_TX_LEVEL_OFFSET = 6'h10;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_RX_LEVEL_OFFSET = 6'h14;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_FLUSH_TIMEOUT_OFFSET = 6'h18;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_FLUSH_THRESH_OFFSET = 6'h1C;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_FLUSH_CHAR_OFFSET = 6'h20;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_TX_WATERMARK_OFFSET = 6'h24;
  parameter logic [BlockAw-1:0] USB_BRIDGE_CSR_RX_WATERMARK_OFFSET = 6'h28;

endpackage

