// Copyright Nu Quantum Ltd
// Copyright 2026 Shareef Jalloq
// SPDX-License-Identifier: MIT
//
// Auto-generated by peakrdl-sv


module gpio_csr_reg_top
  import rdl_subreg_pkg::*;
  import gpio_csr_reg_pkg::*;
#(
  parameter reset_type_e ResetType = ActiveHighSync,
  localparam int AW                = 5,
  localparam int DW                = 32
) (
  input logic clk,
  input logic rst,

  // CPU I/F
  input logic           reg_we,
  input logic           reg_re,
  input logic [AW-1:0]  reg_addr,
  input logic [DW-1:0]  reg_wdata,
  output logic [DW-1:0] reg_rdata,

  // HW I/F
  output gpio_csr_reg_pkg::gpio_csr_reg2hw_t reg2hw, // Write
  input  gpio_csr_reg_pkg::gpio_csr_hw2reg_t hw2reg  // Read
);

  // --------------------------------------------------------------------------------
  // Software Logic Declarations
  // --------------------------------------------------------------------------------

  logic gpio_out_re;
  logic gpio_out_we;
  logic [31:0] gpio_out_data_wd;
  logic gpio_oe_re;
  logic gpio_oe_we;
  logic [31:0] gpio_oe_data_wd;
  logic gpio_in_re;
  logic gpio_ie_re;
  logic gpio_ie_we;
  logic [31:0] gpio_ie_data_wd;
  logic irq_status_re;
  logic irq_status_we;
  logic [31:0] irq_status_data_wd;
  logic irq_enable_re;
  logic irq_enable_we;
  logic [31:0] irq_enable_data_wd;
  logic irq_edge_re;
  logic irq_edge_we;
  logic [31:0] irq_edge_data_wd;
  logic irq_type_re;
  logic irq_type_we;
  logic [31:0] irq_type_data_wd;

  // --------------------------------------------------------------------------------
  // Field Logic
  // --------------------------------------------------------------------------------

  // Register[gpio_out] Field[data] Bits[31:0]
  logic [31:0] gpio_out_data_qs;
  rdl_subreg_ext #(
    .DW (32)
  ) u_gpio_out_data (
    .re  (),
    .we  (gpio_out_we),
    .wd  (gpio_out_data_wd),
    .d   (hw2reg.gpio_out.d),
    .qe  (),
    .qre (),
    .q   (reg2hw.gpio_out.q),
    .qs  (gpio_out_data_qs)
  );

  // Register[gpio_oe] Field[data] Bits[31:0]
  logic [31:0] gpio_oe_data_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_gpio_oe_data (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (gpio_oe_we),
    .wd  (gpio_oe_data_wd),
    .de  ('0),
    .d   ('0),
    .qs  (gpio_oe_data_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.gpio_oe.q)
  );

  // Register[gpio_in] Field[data] Bits[31:0]
  logic [31:0] gpio_in_data_qs;
  assign gpio_in_data_qs = hw2reg.gpio_in.d;

  // Register[gpio_ie] Field[data] Bits[31:0]
  logic [31:0] gpio_ie_data_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_gpio_ie_data (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (gpio_ie_we),
    .wd  (gpio_ie_data_wd),
    .de  ('0),
    .d   ('0),
    .qs  (gpio_ie_data_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.gpio_ie.q)
  );

  // Register[irq_status] Field[data] Bits[31:0]
  logic [31:0] irq_status_data_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteWoclr)
  ) u_irq_status_data (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_status_we),
    .wd  (irq_status_data_wd),
    .de  (hw2reg.irq_status.de),
    .d   (hw2reg.irq_status.d),
    .qs  (irq_status_data_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_status.q)
  );

  // Register[irq_enable] Field[data] Bits[31:0]
  logic [31:0] irq_enable_data_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_enable_data (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_enable_we),
    .wd  (irq_enable_data_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_enable_data_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_enable.q)
  );

  // Register[irq_edge] Field[data] Bits[31:0]
  logic [31:0] irq_edge_data_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_edge_data (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_edge_we),
    .wd  (irq_edge_data_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_edge_data_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_edge.q)
  );

  // Register[irq_type] Field[data] Bits[31:0]
  logic [31:0] irq_type_data_qs;
  rdl_subreg #(
    .DW         (32),
    .ResetType  (ResetType),
    .ResetValue (32'd0),
    .OnRead     (OnReadNone),
    .OnWrite    (OnWriteNone)
  ) u_irq_type_data (
    .clk (clk),
    .rst (rst),
    .re  (),
    .we  (irq_type_we),
    .wd  (irq_type_data_wd),
    .de  ('0),
    .d   ('0),
    .qs  (irq_type_data_qs),
    .qe  (),
    .qre (),
    .q   (reg2hw.irq_type.q)
  );


  // --------------------------------------------------------------------------------
  // Address Decode
  // --------------------------------------------------------------------------------

  logic [7:0] addr_hit;
  always_comb begin
    addr_hit = '0;
    addr_hit[0] = (reg_addr == GPIO_CSR_GPIO_OUT_OFFSET);
    addr_hit[1] = (reg_addr == GPIO_CSR_GPIO_OE_OFFSET);
    addr_hit[2] = (reg_addr == GPIO_CSR_GPIO_IN_OFFSET);
    addr_hit[3] = (reg_addr == GPIO_CSR_GPIO_IE_OFFSET);
    addr_hit[4] = (reg_addr == GPIO_CSR_IRQ_STATUS_OFFSET);
    addr_hit[5] = (reg_addr == GPIO_CSR_IRQ_ENABLE_OFFSET);
    addr_hit[6] = (reg_addr == GPIO_CSR_IRQ_EDGE_OFFSET);
    addr_hit[7] = (reg_addr == GPIO_CSR_IRQ_TYPE_OFFSET);
  end

  // --------------------------------------------------------------------------------
  // Write Enables
  // --------------------------------------------------------------------------------

  assign gpio_out_we = addr_hit[0] && reg_we;
  assign gpio_out_re = addr_hit[0] && reg_re;
  assign gpio_out_data_wd = reg_wdata[31:0];
  assign gpio_oe_we = addr_hit[1] && reg_we;
  assign gpio_oe_re = addr_hit[1] && reg_re;
  assign gpio_oe_data_wd = reg_wdata[31:0];
  assign gpio_in_re = addr_hit[2] && reg_re;
  assign gpio_ie_we = addr_hit[3] && reg_we;
  assign gpio_ie_re = addr_hit[3] && reg_re;
  assign gpio_ie_data_wd = reg_wdata[31:0];
  assign irq_status_we = addr_hit[4] && reg_we;
  assign irq_status_re = addr_hit[4] && reg_re;
  assign irq_status_data_wd = reg_wdata[31:0];
  assign irq_enable_we = addr_hit[5] && reg_we;
  assign irq_enable_re = addr_hit[5] && reg_re;
  assign irq_enable_data_wd = reg_wdata[31:0];
  assign irq_edge_we = addr_hit[6] && reg_we;
  assign irq_edge_re = addr_hit[6] && reg_re;
  assign irq_edge_data_wd = reg_wdata[31:0];
  assign irq_type_we = addr_hit[7] && reg_we;
  assign irq_type_re = addr_hit[7] && reg_re;
  assign irq_type_data_wd = reg_wdata[31:0];

  // --------------------------------------------------------------------------------
  // Read Data Mux
  // --------------------------------------------------------------------------------

  always_comb begin
    reg_rdata = '0;
    unique case (1'b1)
      addr_hit[0]: begin
        reg_rdata[31:0] = gpio_out_data_qs;
      end
      addr_hit[1]: begin
        reg_rdata[31:0] = gpio_oe_data_qs;
      end
      addr_hit[2]: begin
        reg_rdata[31:0] = gpio_in_data_qs;
      end
      addr_hit[3]: begin
        reg_rdata[31:0] = gpio_ie_data_qs;
      end
      addr_hit[4]: begin
        reg_rdata[31:0] = irq_status_data_qs;
      end
      addr_hit[5]: begin
        reg_rdata[31:0] = irq_enable_data_qs;
      end
      addr_hit[6]: begin
        reg_rdata[31:0] = irq_edge_data_qs;
      end
      addr_hit[7]: begin
        reg_rdata[31:0] = irq_type_data_qs;
      end
      default: begin
        reg_rdata = 'X;
      end
    endcase
  end

endmodule
